package io.dwsoft.restx.payload

import io.dwsoft.restx.fault.FaultResult
import io.dwsoft.restx.RestXException
import io.dwsoft.restx.fault.FaultCauseProcessor
import io.dwsoft.restx.fault.MultipleCauseResolver
import io.dwsoft.restx.fault.SingleCauseResolver

/**
 * Base interface for generators of [FaultResult] response payloads.
 *
 * @param T type of fault objects that generators of this class supports
 * @param R specific type of [ErrorResponsePayload] generated by objects of this class
 */
sealed interface ErrorPayloadGenerator<T : FaultResult, R : ErrorResponsePayload> {
    /**
     * Method that generates payload for given [FaultResult]
     *
     * @throws RestXException in case of errors during generation process
     */
    fun payloadOf(fault: T): R
}

/**
 * Generator creating payloads for [FaultResult]s caused by single errors.
 */
class SingleErrorPayloadGenerator<T : FaultResult>(
    private val causeResolver: SingleCauseResolver<T>,
    private val processor: FaultCauseProcessor<T>
) : ErrorPayloadGenerator<T, ApiError> {
    override fun payloadOf(fault: T): ApiError {
        return processor.process(causeResolver(fault))
    }
}

/**
 * Interface for generators creating payloads for [FaultResult]s caused by multiple errors
 * (e.g. validation errors of multiple input parameters).
 */
class MultiErrorPayloadGenerator<T : FaultResult>(
    private val resolver: MultipleCauseResolver<T>,
    private val processor: FaultCauseProcessor<T>
) : ErrorPayloadGenerator<T, ErrorResponsePayload> {
    /**
     * Generator method
     *
     * @throws NoCausesResolved in case [resolver] returns empty collection of causes
     */
    override fun payloadOf(fault: T): ErrorResponsePayload {
        return (resolver(fault).takeIf { it.isNotEmpty() } ?: throw NoCausesResolved())
            .map { processor.process(it) }
            .toPayload()
    }
}

class NoCausesResolved : RestXException()