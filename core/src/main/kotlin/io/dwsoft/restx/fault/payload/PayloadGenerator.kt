package io.dwsoft.restx.fault.payload

import io.dwsoft.restx.InitBlock
import io.dwsoft.restx.RestXException
import io.dwsoft.restx.fault.cause.CauseProcessors
import io.dwsoft.restx.fault.cause.CauseResolvers
import io.dwsoft.restx.fault.cause.CauseProcessor
import io.dwsoft.restx.fault.cause.MultipleCauseResolver
import io.dwsoft.restx.fault.cause.SingleCauseResolver

/**
 * Base interface for generators of error response payloads.
 *
 * @param T type of fault objects that generators of this class supports
 * @param R specific type of [ErrorResponsePayload] generated by objects of this class
 */
sealed interface ErrorPayloadGenerator<in T : Any, out R : ErrorResponsePayload> {
    /**
     * Method that generates payload for given fault result
     *
     * @throws RestXException in case of errors during generation process
     */
    fun payloadOf(fault: T): R

    /**
     * Facade to payload generators builders
     */
    object Builders {
        infix fun <T : Any> error(
            initBlock: InitBlock<SingleErrorPayloadGenerator.Builder.Config<T>>
        ): SingleErrorPayloadGenerator<T> =
            SingleErrorPayloadGenerator.buildFrom(
                SingleErrorPayloadGenerator.Builder.Config<T>().apply(initBlock)
            )

        infix fun <T : Any> errors(
            initBlock: InitBlock<MultiErrorPayloadGenerator.Builder.Config<T>>
        ): MultiErrorPayloadGenerator<T> =
            MultiErrorPayloadGenerator.buildFrom(
                MultiErrorPayloadGenerator.Builder.Config<T>().apply(initBlock)
            )

        infix fun <T : Any> basic(
            generatorFactory: PayloadGenerators.() -> ErrorPayloadGenerator<T, *>
        ): ErrorPayloadGenerator<T, *> = generatorFactory(PayloadGenerators)
    }
}

/**
 * Factories of common implementation of [ErrorPayloadGenerator]s.
 * Additional factory methods should be added as an extension functions.
 */
object PayloadGenerators

/**
 * Generator creating payloads for fault results caused by single errors.
 */
class SingleErrorPayloadGenerator<T : Any>(
    private val causeResolver: SingleCauseResolver<T>,
    private val processor: CauseProcessor<T>
) : ErrorPayloadGenerator<T, ApiError> {
    override fun payloadOf(fault: T): ApiError {
        return processor.process(causeResolver.causeOf(fault))
    }

    companion object Builder {
        fun <T : Any> buildFrom(config: Config<T>): SingleErrorPayloadGenerator<T> {
            checkNotNull(config.causeResolverFactory) { "Cause resolver factory must be provided" }
            checkNotNull(config.causeProcessorFactory) { "Cause processor factory must be provided" }
            return SingleErrorPayloadGenerator(
                (config.causeResolverFactory!!)(CauseResolvers),
                (config.causeProcessorFactory!!)(CauseProcessors)
            )
        }

        class Config<T : Any> {
            var causeResolverFactory: (SingleCauseResolverFactory<T>)? = null
                private set
            var causeProcessorFactory: (CauseProcessorFactory<T>)? = null
                private set

            fun identifiedBy(causeResolverFactory: SingleCauseResolverFactory<T>) {
                this.causeResolverFactory = causeResolverFactory
            }

            fun processedBy(causeProcessorFactory: CauseProcessorFactory<T>) {
                this.causeProcessorFactory = causeProcessorFactory
            }
        }
    }
}

/**
 * Interface for generators creating payloads for fault results caused by multiple errors
 * (e.g. validation errors of multiple input parameters).
 */
class MultiErrorPayloadGenerator<T : Any>(
    private val resolver: MultipleCauseResolver<T>,
    private val processor: CauseProcessor<T>
) : ErrorPayloadGenerator<T, ErrorResponsePayload> {
    /**
     * Generator method
     *
     * @throws NoCausesResolved in case [resolver] returns empty collection of causes
     */
    override fun payloadOf(fault: T): ErrorResponsePayload {
        return (resolver.causesOf(fault).takeIf { it.isNotEmpty() } ?: throw NoCausesResolved())
            .map { processor.process(it) }
            .toPayload()
    }

    companion object Builder {
        fun <T : Any> buildFrom(config: Config<T>): MultiErrorPayloadGenerator<T> {
            checkNotNull(config.causeResolverFactory) { "Cause resolver factory must be provided" }
            checkNotNull(config.causeProcessorFactory) { "Cause processor factory must be provided" }
            return MultiErrorPayloadGenerator(
                (config.causeResolverFactory!!)(CauseResolvers),
                (config.causeProcessorFactory!!)(CauseProcessors)
            )
        }

        class Config<T : Any> {
            var causeResolverFactory: (MultipleCauseResolverFactory<T>)? = null
                private set
            var causeProcessorFactory: (CauseProcessorFactory<T>)? = null
                private set

            fun identifiedBy(causeResolverFactory: MultipleCauseResolverFactory<T>) {
                this.causeResolverFactory = causeResolverFactory
            }

            fun processedBy(causeProcessorFactory: CauseProcessorFactory<T>) {
                this.causeProcessorFactory = causeProcessorFactory
            }
        }
    }
}

class NoCausesResolved : RestXException()

typealias SingleCauseResolverFactory<T> = CauseResolvers.() -> SingleCauseResolver<T>
typealias MultipleCauseResolverFactory<T> = CauseResolvers.() -> MultipleCauseResolver<T>
typealias CauseProcessorFactory<T> = CauseProcessors.() -> CauseProcessor<T>